#from google.cloud.datastore.helpers import GeoPoint # https://googleapis.github.io/google-cloud-python/latest/index.html
#from google.cloud.firestore_v1beta1 import GeoPoint
from firebase_admin.firestore import GeoPoint
from dataclasses import dataclass, field, InitVar, asdict
from datetime import datetime


"""

COMMON PROPERTIES that are used in workout, track and segment objects/documents:
{
    start_time: date,
    end_time: date,
    distance: number, (in km)
    total_time: number, (in seconds)
    moving_time: number,
    stopped_time: number,
    avg: number, (km/h)
    max_speed: number,
    uphill: number, (meters)
    downhill: number,
}

WORKOUT (treeni):
{
    id: string (autogenerated)
    name: string,
    sport: string,
    description: string,
    date_added: date
    [COMMON PROPERTIES FOR WORKOUT]
}

TRACK (in tracks subcollection of workout)
{
    id: string, (autogenerated)
    track_number: number (1,2,3,... position inside gpx-tag)
    [COMMON PROPERTIES FOR TRACK]
    segments: Map(1: {                                          <--- TODO: segments are stored in an map (not array) because firestore has very limited support for array operations.
        segment_number: 1,                                           However, it is possible to replace whole array with updated one.
        [COMMON PROPERTES FOR SEGMENT]
        coordinates: [{lat: number, lng: number}],                 <--- if the are not geopoints, unindex this from firestore console, so that we dont hit the 20k indexed fields per document limit
        elevations: [...],                                       <--- good idea to unindex all the arrays, eventhought they don't contains fields
        times_from_start: [...],                                      https://firebase.googleblog.com/2018/08/more-cloud-firestore-improvements.html
        distances_from_start: [...],
        speeds: [...]
        },
         seg2: {
            ...
        },
        ...
    }
}

SEGMENT
{
    segment_number: int
    coordinates: list
    elevations: list
    times_from_start: list
    distances_from_start: list
    speeds: list 
}

*****

UNITS:
alitude: meters
distance: meters
time: seconds
speed: m/s

"""
@dataclass
class GpxProperties:
    
    gpx_part: InitVar[str] # init-only field, not part of self

    # Properties, init=False prevents them being added as __init__ parameters
    # Also argument with default value set cannot be followed by non-default argument (from child class)
    start_time: datetime = field(default=None, init=False)
    end_time: datetime = field(default=None, init=False)
    distance: float = field(default=0, init=False)  # (meters)
    moving_time: float = field(default=0, init=False) 
    stopped_time: float = field(default=0, init=False)
    total_time: float = field(default=0, init=False)
    avg_with_stops: float = field(default=None, init=False)  # (m/s)
    avg_without_stops: float = field(default=None, init=False) # (m/s)
    max_speed: float = field(default=0, init=False) # (m/s)
    uphill: float = field(default=0, init=False) # (meters)
    downhill: float = field(default=0, init=False) # (meters)
    bounds: list = field(default_factory=list, init=False)

    # called from generated __init__
    def __post_init__(self, gpx_part):
        self.calculate_properties(gpx_part)

    def calculate_properties(self, gpx_part):
        self.start_time, self.end_time = gpx_part.get_time_bounds()
        self.distance = gpx_part.length_3d()
        moving_data = gpx_part.get_moving_data() # returns named tuple, uses default threshold for stops (<1km/h), could adjust based on activity
        self.moving_time = moving_data.moving_time
        self.stopped_time = moving_data.stopped_time
        self.total_time = self.moving_time + self.stopped_time # excludes time between segments and tracks but includes stops
        self.avg_with_stops = self.distance / self.total_time if self.total_time > 0 else None
        self.avg_without_stops = moving_data.moving_distance / moving_data.moving_time if moving_data.moving_time > 0 else None
        
        # max speed is calculation is weird in gpxpy, uses too much filtering:
        # filters poinst where distance to previous point is more than 1.5 sd
        # if max value is wanted why filter them out, why not just smooth the track if needed???
        self.max_speed = moving_data.max_speed

        self.uphill, self.downhill = gpx_part.get_uphill_downhill()

        bounds = gpx_part.get_bounds()
        self.bounds = {'min': GeoPoint(bounds.min_latitude, bounds.min_longitude), \
                        'max': GeoPoint(bounds.max_latitude, bounds.max_longitude)}

@dataclass
class Workout(GpxProperties):
    name: str
    uid: str # user id for saving
    sport: str = None
    description: str = None
    date_added: datetime = field(default_factory=datetime.utcnow, init=False)
    # tracks
    tracks: list = field(default_factory=list) # use field-function to create mutable data types
    
    def __post_init__(self, gpx):
        #TODO: smooth gpx?
        #loop gpx tracks
        for track_number, track in enumerate(gpx.tracks):
            self.tracks.append(Track(track, track_number))
        
        super().__post_init__(gpx)# not very efficiant, could use tracks' properties to calculate workout's propertie here



@dataclass
class Track(GpxProperties):
    track_number: int
    segments: list = field(default_factory=list)  #TODO: use dict insted of an array for better compatability with firestore?
    
    def __post_init__(self, gpx_track):
        #loop track segments here...
        for segment_number, segment in enumerate(gpx_track.segments):
            self.segments.append(Segment(segment, segment_number))
        
        super().__post_init__(gpx_track) # not very efficiant, could use segments' properties to calculate track properties


@dataclass
class Segment(GpxProperties):
    segment_number: int
    # points
    coordinates: list = field(default_factory=list)
    elevations: list = field(default_factory=list)
    times_from_start: list = field(default_factory=list)
    distances_from_start: list = field(default_factory=list)
    speeds: list = field(default_factory=list)                  #TODO calculate speeds
        
    def __post_init__(self, gpx_segment):
        super().__post_init__(gpx_segment)
        
        self.calculate_point_data(gpx_segment)


    def calculate_point_data(self, gpx_segment):
        distance_from_start = 0
        time_from_start = 0
        previous_point = None
        for point in gpx_segment.points:

            self.coordinates.append(GeoPoint(point.latitude, point.longitude))
            self.elevations.append(point.elevation) # if point has no elevation data, None is appended
            # distances from start (of a segment)
            if (previous_point):
                #distances
                distance = point.distance_3d(previous_point) # if no elevation data distance_3d uses 2d distance
                distance_from_start += distance
                self.distances_from_start.append(distance_from_start)
                
                #times
                time = point.time_difference(previous_point) # if points are missing time, None is returned
                if(time):
                    time_from_start += time
                    self.times_from_start.append(time_from_start)
                else:
                    self.times_from_start.append(None)

            else: # first point
                self.distances_from_start.append(0)
                self.times_from_start.append(0)

            previous_point = point
            #TODO: check if segment has elevation and time data before adding them to self to avoid arrays with only None values
            #      gpxpy has methods for these but they are little heavy(?)

#TODO: test segment code





        

# In this class all properties are calculated when instances are created.
# One alternative would initialize properties with empty values and calculate them in getters (marked with @property)

# Some gpxpy: methods return None and some 0 if data not found, for example
# get_uphill_downhill -> (0,0,) but get_elevation_extremes -> (None, None)

# moving_data could be better to calculte from smoothed version of gpx like suggested in gpxpy docs

# gpxpy does not seem to provide effiant way to calculate properties for all gpx-parts (segments, tracks, gpx)
# effiantly. Could re-use the segment properties to calculate track properties and so on. Now segment properties are
# calculted three time, once for the segment itself, once for track, once for gpx (workout-class).

# All dataclass fields except init-vars are added to dictionary when callin asdict(object). If there is need for
# instance variable, instance variable set in __post_init__ will probably not be included in the dict.
# asdict function's dict_factory parameter can also be probably used to filter key-values tupples and only add some of them to dict,